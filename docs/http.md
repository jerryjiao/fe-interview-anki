# http

## GET和POST请求的区别有哪些?

### 答题思路

这是一个关于HTTP协议基本概念的问题，询问的是GET和POST请求的区别。我们可以从以下几个角度进行回答：

1. 从语义上来说，GET用于获取资源，而POST用于提交数据。
2. 在浏览器中，GET请求的参数会显示在URL中，而POST请求的参数则在请求体中。
3. GET请求的参数长度受到URL长度的限制，而POST请求的参数长度没有明确的限制。
4. GET请求可以被缓存和收藏为书签，而POST请求不可以。
5. GET请求是安全的和幂等的，而POST请求不是。

### 答题关键点

- GET和POST的语义
- 请求参数的位置
- 参数长度的限制
- 是否可被缓存和收藏
- 安全性和幂等性

### 答案示例

GET和POST是HTTP协议中最常见的两种请求方法，它们有以下主要的区别：

1. 语义：GET请求用于获取资源，POST请求用于提交数据。
2. 请求参数位置：GET请求的参数会显示在URL中，而POST请求的参数则在请求体中。
3. 参数长度限制：GET请求的参数长度受到URL长度的限制，而POST请求的参数长度没有明确的限制。
4. 缓存和书签：GET请求可以被缓存和收藏为书签，而POST请求不可以。
5. 安全性和幂等性：GET请求是安全的和幂等的，而POST请求不是。这意味着重复的GET请求会得到相同的结果，而重复的POST请求可能会有不同的结果。

### 关键点脑图

```
- GET vs POST
  - 语义
    - GET: 获取资源
    - POST: 提交数据
  - 请求参数位置
    - GET: URL中
    - POST: 请求体中
  - 参数长度限制
    - GET: 有限制
    - POST: 无明确限制
  - 缓存和书签
    - GET: 可以被缓存和收藏
    - POST: 不可以
  - 安全性和幂等性
    - GET: 是
    - POST: 否

```

## HTTP/1.1 和 HTTP/2 的区别有哪些？

### 答题思路

这是一个技术比较题，主要比较的是两个不同版本的 HTTP 协议的区别。我们需要根据我们对这两个版本的理解，从多个角度进行比较，包括多路复用，头信息压缩，二进制传输，服务器推送等方面。

### 答题关键点

1. 多路复用
2. 头信息压缩
3. 二进制传输
4. 服务器推送

### 答案示例

HTTP/1.1 和 HTTP/2 主要有以下几点不同：

1. **多路复用**：HTTP/1.1 虽然可以并发多个请求，但每个连接只能处理一个请求，响应必须按照请求的顺序返回，所以存在队头阻塞（Head Of Line Blocking）问题。而 HTTP/2 通过多路复用支持同时多个请求和响应，并且按照优先级来发送请求和响应，解决了队头阻塞问题。
2. **头信息压缩**：HTTP/1.1 的请求和响应头信息都是文本形式，并且每次请求和响应都要带上完整的头信息，增加了传输的数据量。HTTP/2 使用 HPACK 算法对头信息进行压缩，可以减少数据的传输量。
3. **二进制传输**：HTTP/1.1 的数据传输是基于文本的，而 HTTP/2 的数据传输是基于二进制的，二进制协议解析起来更高效，更小的错误可能性。
4. **服务器推送**：HTTP/2 新增了服务器推送功能，当服务器认为客户端将会需要的资源，可以不用客户端请求，主动推送给客户端。

### 关键点脑图

```
- HTTP/1.1 和 HTTP/2 的区别
  - 多路复用
    - HTTP/1.1：一个连接只能处理一个请求，存在队头阻塞问题
    - HTTP/2：通过多路复用支持同时多个请求和响应，解决了队头阻塞问题
  - 头信息压缩
    - HTTP/1.1：每次请求和响应都要带上完整的头信息
    - HTTP/2：使用 HPACK 算法对头信息进行压缩，减少了数据的传输量
  - 二进制传输
    - HTTP/1.1：数据传输是基于文本的
    - HTTP/2：数据传输是基于二进制的，解析更高效
  - 服务器推送
    - HTTP/1.1：无此功能
    - HTTP/2：服务器可以主动推送资源给客户端

```

## HTTP和HTTPS的区别有哪些？

### 答题思路

这是一个关于HTTP协议和HTTPS协议的问题，询问的是HTTP和HTTPS的区别。我们可以从以下几个角度进行回答：

1. 安全性：HTTP是明文传输，而HTTPS通过SSL/TLS协议进行了加密。
2. 端口号：HTTP的默认端口号是80，HTTPS的默认端口号是443。
3. 性能：由于HTTPS需要进行加密解密操作，所以性能上会稍逊于HTTP。
4. 证书：HTTPS需要申请、安装SSL/TLS证书。

### 答题关键点

- 安全性
- 端口号
- 性能
- 证书

### 答案示例

HTTP和HTTPS主要有以下几个区别：

1. 安全性：HTTP是明文传输，数据在传输过程中可能会被窃取或篡改。而HTTPS使用了SSL/TLS协议对数据进行了加密，可以保证数据的完整性和私密性，更加安全。
2. 端口号：HTTP的默认端口号是80，而HTTPS的默认端口号是443。
3. 性能：由于HTTPS需要进行加密解密操作，以及建立一个SSL/TLS会话，所以性能上会稍逊于HTTP。但是随着硬件性能的提升，这种差距正在逐渐缩小。
4. 证书：HTTPS需要申请、安装SSL/TLS证书。如果证书不被客户端信任，那么浏览器会给出警告。

### 关键点脑图

```
- HTTP vs HTTPS
  - 安全性
    - HTTP: 明文传输
    - HTTPS: 加密传输
  - 端口号
    - HTTP: 80
    - HTTPS: 443
  - 性能
    - HTTP: 高
    - HTTPS: 稍低
  - 证书
    - HTTP: 不需要
    - HTTPS: 需要

```
## HTTP缓存有哪些方案？

### 答题思路

这是一个关于HTTP缓存的问题，询问的是HTTP缓存的策略。我们可以从以下几个角度进行回答：

1. 强缓存：使用Expires和Cache-Control头部字段来实现。
2. 协商缓存：使用Last-Modified/If-Modified-Since和ETag/If-None-Match头部字段来实现。

### 答题关键点

- 强缓存
    - Expires
    - Cache-Control
- 协商缓存
    - Last-Modified/If-Modified-Since
    - ETag/If-None-Match

### 答案示例

HTTP缓存主要有以下两种策略：

1. 强缓存：强缓存通过HTTP响应头中的Expires和Cache-Control来实现。当客户端发起请求时，会先检查本地是否有缓存的资源。如果有，并且缓存的资源是新鲜的（在有效期内），那么就直接使用缓存的资源，不会发送请求到服务器。
    - Expires：HTTP/1.0中的字段，其值是一个绝对的时间（例如：Thu, 01 Dec 1994 16:00:00 GMT），表示缓存资源的过期时间。
    - Cache-Control：HTTP/1.1中的字段，其值是相对时间，例如max-age=3600，表示资源会在3600秒后过期。
2. 协商缓存：当本地缓存的资源过期时，客户端会携带缓存信息（通常是一个时间戳或者标签）发送到服务器，由服务器判断资源是否有更新。如果没有更新，服务器会返回304 Not Modified，客户端就可以继续使用缓存的资源。如果有更新，服务器会返回新的资源和缓存信息。协商缓存通过HTTP响应头中的Last-Modified/If-Modified-Since和ETag/If-None-Match来实现。
    - Last-Modified/If-Modified-Since：服务器通过Last-Modified表示资源的最后修改时间，客户端通过If-Modified-Since携带上一次接收到的Last-Modified的值，如果资源没有变化，服务器返回304和空的响应体。
    - ETag/If-None-Match：ETag是服务器为每个资源生成的一个唯一的标识符，客户端通过If-None-Match携带上一次接收到的ETag的值，如果资源没有变化，服务器返回304和空的响应体。

### 关键点脑图

```
- HTTP缓存
  - 强缓存
    - Expires
    - Cache-Control
  - 协商缓存
    - Last-Modified/If-Modified-Since
    - ETag/If-None-Match

```
## Session、Cookie、LocalStorage、SessionStorage 的区别

### 答题思路

这个问题是一个理解浏览器存储机制和HTTP协议基础的题目。我们需要详细解释每个概念的定义，用途，和他们之间的差异。当回答这种类型的问题时，我们应当从以下几个角度进行阐述：

1. 定义和使用场景：解释每种技术的基本概念和主要用途。
2. 生命周期：这些技术的数据存活时间是多久？
3. 存储大小：这些技术能存储多少数据？
4. 可访问性：这些技术在哪些情况下可以被访问？
5. 安全性：这些技术的数据安全性如何？

### 答题关键点

1. **Session**：基于服务器的数据存储机制，生命周期取决于服务器设置，用于保存用户相关信息。
2. **Cookie**：客户端存储技术，大小受限，常用于保存少量数据如用户凭证等，跨越请求共享。
3. **LocalStorage**：客户端存储技术，生命周期长，不受标签页关闭影响，存储量大，常用于长期保存用户相关信息。
4. **SessionStorage**：客户端存储技术，生命周期随标签页，存储量大，常用于临时保存用户相关信息。

### 答案示例

| 技术 | 生命周期 | 存储大小 | 可访问性 | 安全性 |
| --- | --- | --- | --- | --- |
| Session | 服务器决定，通常在用户关闭浏览器或超过一定时间后销毁 | 服务器内存大小决定，理论上无上限 | 任何地方，只要有权限 | 取决于服务器的安全性设置，通常较高 |
| Cookie | 手动设置，未设置则默认在浏览器关闭时销毁 | 4KB | 所有同源请求中都会自动携带 | 数据在每次请求时都会被发送，因此相对较低 |
| LocalStorage | 除非手动删除，否则一直存在 | 5MB - 10MB，取决于浏览器 | 同源的所有窗口或标签页 | 只有在客户端才能访问，因此较高 |
| SessionStorage | 浏览器窗口或标签页关闭时销毁 | 5MB - 10MB，取决于浏览器 | 同源的当前窗口或标签页 | 只有在客户端才能访问，因此较高 |

### 关键点脑图

```markdown
- Session
  - 生命周期：服务器决定
  - 存储大小：由服务器内存大小决定
  - 可访问性：任何地方，只要有权限
  - 安全性：较高
- Cookie
  - 生命周期：手动设置
  - 存储大小：4KB
  - 可访问性：所有同源请求
  - 安全性：较低
- LocalStorage
  - 生命周期：除非手动删除，否则一直存在
  - 存储大小：5MB - 10MB
  - 可访问性：同源的所有窗口或标签页
  - 安全性：较高
- SessionStorage
  - 生命周期：浏览器窗口或标签页关闭时销毁
  - 存储大小：5MB - 10MB
  - 可访问性：同源的当前窗口或标签页
  - 安全性：较高

```
## TCP三次握手和四次挥手是什么？

### 答题思路

这是一个网络基础知识的解释概念题。在解答这个问题时，我们需要清晰地解释 TCP 协议中的三次握手和四次挥手的流程以及它们的作用。

### 答题关键点

1. TCP 协议
2. 三次握手
3. 四次挥手

### 答案示例

TCP 协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，其中三次握手和四次挥手是其建立连接和断开连接的基本流程。

**三次握手**的过程是：

1. 客户端发送 SYN 包（SYN=j）到服务器，并进入 SYN_SEND 状态，等待服务器确认。
2. 服务器收到 SYN 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（SYN=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。
3. 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

**四次挥手**的过程是：

1. 主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，主动关闭方进入 FIN_WAIT_1 状态。
2. 被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（ack=m+1），被动关闭方进入 CLOSE_WAIT 状态。
3. 被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，被动关闭方进入 LAST_ACK 状态。
4. 主动关闭方收到 FIN 后，进入 TIME_WAIT 状态，发送 ACK 给被动关闭方。

### 关键点脑图

```
- TCP 三次握手和四次挥手
  - 三次握手
    - 客户端发送 SYN 包到服务器
    - 服务器确认 SYN 包并发送自己的 SYN 包
    - 客户端确认服务器的 SYN 包
  - 四次挥手
    - 主动关闭方发送 FIN 包
    - 被动关闭方确认 FIN 包
    - 被动关闭方发送自己的 FIN 包
    - 主动关闭方确认 FIN 包

```
## 描述一下 HTTP 协议以及常见的 HTTP 状态码

### 答题思路

这个问题是一个网络协议类的问题，主要是对HTTP协议及其状态码的理解。在回答这个问题时，你应当首先解释HTTP协议的基本概念，然后列出并解释一些常见的HTTP状态码。

### 答题关键点

1. **HTTP协议**：HTTP协议是一个无状态的请求-响应协议，用于客户端和服务器之间的通信。
2. **常见的HTTP状态码**：状态码是服务器对客户端请求的响应结果，常见的有200、404、301、302、500等。

### 答案示例

HTTP（HyperText Transfer Protocol）协议是一种无状态的请求-响应协议，它定义了客户端（通常是浏览器）如何向服务器发送请求，以及服务器如何响应这些请求。HTTP消息包括请求消息和响应消息，每个消息都包含一个起始行、一些头部字段和一个消息体。

常见的HTTP状态码有：

- **2xx 成功**：这一类的状态码表示请求已被成功接收、理解和接受。如：
    - 200 OK：请求成功。
- **3xx 重定向**：这一类状态码表示需要客户端采取进一步操作才能完成请求。如：
    - 301 Moved Permanently：永久重定向。
    - 302 Found：临时重定向。
- **4xx 客户端错误**：这类状态码表示客户端可能出错，需要修改请求。如：
    - 404 Not Found：请求的资源未找到。
- **5xx 服务器错误**：这类状态码表示服务器在尝试处理请求时发生内部错误。如：
    - 500 Internal Server Error：服务器内部错误。

### 关键点脑图

```markdown
- HTTP协议
  - 请求-响应协议
  - 无状态
- 常见的HTTP状态码
  - 2xx 成功
    - 200 OK
  - 3xx 重定向
    - 301 Moved Permanently
    - 302 Found
  - 4xx 客户端错误
    - 404 Not Found
  - 5xx 服务器错误
    - 500 Internal Server Error

```
## 描述一下浏览器的渲染过程

### 答题思路

这是一个关于浏览器工作原理的问题，它需要对浏览器的渲染过程有深入的理解。答题的关键点包括HTML解析、CSS解析、DOM和CSSOM构建、渲染树构建、布局、以及绘制等步骤。在回答这个问题时，你需要详细地描述每个步骤的工作内容，以展示你对浏览器渲染过程的理解。

### 答题关键点

1. **HTML解析**：浏览器接收到HTML文件后，会将其解析成DOM树。
2. **CSS解析**：同时，浏览器也会解析CSS文件和`<style>`标签内的CSS，生成CSSOM树。
3. **构建渲染树**：DOM树和CSSOM树构建完成后，浏览器会将二者结合生成渲染树。
4. **布局**：有了渲染树后，浏览器就能知道网页中有哪些节点、各个节点的CSS定义，接着浏览器就会进行布局（也称为回流），计算出每个节点在屏幕中的位置。
5. **绘制**：布局阶段结束后，浏览器会调用GPU进行绘制（也称为重绘），将各个节点绘制到屏幕的指定位置。

### 答案示例

浏览器的渲染过程如下：

1. **HTML解析**：浏览器首先解析HTML文档，构建DOM树。HTML解析器会将HTML文档转换为DOM树的节点，从`<html>`开始，然后逐步添加更多的节点。
2. **CSS解析**：同时，浏览器会解析内联和外部CSS以及其他用户代理样式，构建出CSSOM树。
3. **构建渲染树**：当DOM树和CSSOM树都准备就绪后，浏览器会将它们结合在一起，构建一个包含有颜色和大小等属性的渲染树。
4. **布局**：有了渲染树后，浏览器就可以进行布局或回流，计算出每个节点在屏幕上的位置。
5. **绘制**：最后一步是绘制，也称为重绘。浏览器会遍历渲染树，使用UI后端层将每个节点绘制出来。

这个过程可能会多次重复，因为浏览器可能需要根据用户的交互、脚本的操作等进行回流和重绘。

### 关键点脑图

```markdown
- 浏览器渲染过程
  - HTML解析
    - 解析HTML文档，生成DOM树
  - CSS解析
    - 解析CSS规则，生成CSSOM树
  - 构建渲染树
    - 将DOM树和CSSOM树结合，生成渲染树
  - 布局
    - 根据渲染树计算节点的布局信息
  - 绘制
    - 根据布局信息和渲染树，将节点绘制到屏幕上

```
## 用XMLHttpRequest实现ajax

### 答题思路

这是一个关于如何使用XMLHttpRequest对象实现AJAX的编程题。在回答这个问题时，你需要写出使用XMLHttpRequest对象发送HTTP请求的步骤和代码。

### 答题关键点

1. **创建XMLHttpRequest对象**：首先需要创建一个XMLHttpRequest对象。
2. **打开连接**：使用open()方法设置请求的方法、URL以及是否异步。
3. **发送请求**：使用send()方法发送请求。
4. **处理响应**：通过onreadystatechange事件监听请求状态的变化，当请求完成时处理响应。

### 答案示例

以下是使用XMLHttpRequest对象实现AJAX的示例代码：

```jsx
// 创建XMLHttpRequest对象
var xhr = new XMLHttpRequest();

// 打开连接
// 使用GET方法请求，URL为"/api/data"，异步为true
xhr.open("GET", "/api/data", true);

// 发送请求
xhr.send();

// 监听状态变化
xhr.onreadystatechange = function() {
  // readyState为4表示请求已完成
  // status为200表示服务器响应成功
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
  }
};

```

### 关键点脑图

```markdown
- XMLHttpRequest实现AJAX
  - 创建XMLHttpRequest对象
    - `var xhr = new XMLHttpRequest();`
  - 打开连接
    - `xhr.open("GET", "/api/data", true);`
  - 发送请求
    - `xhr.send();`
  - 处理响应
    - `xhr.onreadystatechange = function() {...};`

```
## 说说同源策略和跨域

### 答题思路

这是一个关于网络安全的解释概念题。同源策略是浏览器的一个重要的安全机制，跨域则是由于同源策略的限制，需要进行一些额外的处理。我们需要清晰地解释同源策略的定义，以及如何进行跨域操作。

### 答题关键点

1. 同源策略
2. 跨域
3. 跨域解决方案

### 答案示例

**同源策略**是浏览器的一个重要的安全策略，它的定义是：如果两个页面的协议、域名和端口都相同，那么这两个页面同源。浏览器在处理某些操作时，如 AJAX 请求、Cookie、localStorage 等，都会受到同源策略的限制，不能访问非同源的资源。

**跨域**则是当一个页面需要访问另一个非同源页面的资源时，就会出现跨域的情况。由于同源策略的限制，直接访问通常会被浏览器禁止，所以我们需要使用一些方法来进行跨域操作。

常用的**跨域解决方案**包括：

1. **JSONP**：利用 `<script>` 标签不受同源策略的影响，通过动态创建 `<script>` 标签来调用服务器提供的 js 文件，并将需要传递的数据以参数形式在 URL 中传递。
2. **CORS**：服务器设置 `Access-Control-Allow-Origin` 等 CORS 相关的响应头，允许浏览器跨域访问。
3. **使用代理服务器**：在服务器端设置一个代理，让代理去请求目标资源，然后再将获取的资源返回给前端，因为这样的请求是在服务器端发出的，所以不会受到同源策略的限制。

### 关键点脑图

```
- 同源策略和跨域
  - 同源策略
    - 定义：协议、域名、端口都相同
    - 作用：限制 AJAX、Cookie、localStorage 等访问非同源资源
  - 跨域
    - 定义：访问非同源页面的资源
    - 解决方案
      - JSONP
      - CORS
      - 代理服务器

```